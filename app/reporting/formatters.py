import csv
import io
import json
import tempfile
from datetime import datetime
from django.http import HttpResponse
from django.template.loader import get_template
from django.utils import timezone
import logging
import os
import xlsxwriter
import pdfkit
from weasyprint import HTML, CSS

logger = logging.getLogger(__name__)

class BaseFormatter:
    """Base class for report output formatters"""
    
    def __init__(self, report_def, report_data):
        self.report = report_def
        self.data = report_data.get('data', [])
        self.metadata = report_data.get('metadata', {})
        self.filename = self._get_filename()
    
    def _get_filename(self):
        """Generate a filename for the report"""
        timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
        safe_name = self.report.name.replace(' ', '_').lower()
        return f"{safe_name}_{timestamp}"
    
    def get_http_response(self):
        """Return an HTTP response with the formatted report"""
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_file(self):
        """Return the report as a file-like object"""
        raise NotImplementedError("Subclasses must implement this method")
    
    def get_columns(self):
        """Extract column info from the data"""
        if not self.data:
            return []
            
        # Get columns from the first row
        first_row = self.data[0]
        return list(first_row.keys())


class ExcelFormatter(BaseFormatter):
    """Format report data as an Excel file"""
    
    def get_http_response(self):
        output = self.get_file()
        response = HttpResponse(
            output.getvalue(),
            content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        response['Content-Disposition'] = f'attachment; filename="{self.filename}.xlsx"'
        return response
    
    def get_file(self):
        """Generate an Excel file from the report data"""
        output = io.BytesIO()
        
        # Create Excel workbook and worksheet
        workbook = xlsxwriter.Workbook(output)
        worksheet = workbook.add_worksheet()
        
        # Add title and metadata
        title_format = workbook.add_format({'bold': True, 'font_size': 14})
        worksheet.write(0, 0, self.report.name, title_format)
        
        # Add metadata
        meta_format = workbook.add_format({'italic': True})
        row = 2
        worksheet.write(row, 0, f"Generated: {self.metadata.get('generated_at')}", meta_format)
        row += 1
        worksheet.write(row, 0, f"Generated by: {self.metadata.get('generated_by')}", meta_format)
        row += 2  # Skip a row
        
        # Add headers
        header_format = workbook.add_format({'bold': True, 'bg_color': '#DDDDDD'})
        columns = self.get_columns()
        for col, column_name in enumerate(columns):
            # Convert snake_case to Title Case for display
            display_name = column_name.replace('_', ' ').title()
            worksheet.write(row, col, display_name, header_format)
        
        # Write data
        row += 1
        date_format = workbook.add_format({'num_format': 'yyyy-mm-dd'})
        datetime_format = workbook.add_format({'num_format': 'yyyy-mm-dd hh:mm'})
        
        for data_row in self.data:
            for col, column_name in enumerate(columns):
                value = data_row.get(column_name)
                
                # Format dates and datetimes
                if isinstance(value, datetime):
                    worksheet.write_datetime(row, col, value, datetime_format)
                elif hasattr(value, 'date') and callable(getattr(value, 'date')):
                    worksheet.write_datetime(row, col, value, date_format)
                else:
                    worksheet.write(row, col, value)
            row += 1
        
        # Auto fit columns
        for col, _ in enumerate(columns):
            worksheet.set_column(col, col, 15)  # Set a reasonable default width
        
        workbook.close()
        output.seek(0)
        return output


class CSVFormatter(BaseFormatter):
    """Format report data as a CSV file"""
    
    def get_http_response(self):
        output = self.get_file()
        response = HttpResponse(
            output.getvalue(),
            content_type='text/csv'
        )
        response['Content-Disposition'] = f'attachment; filename="{self.filename}.csv"'
        return response
    
    def get_file(self):
        """Generate a CSV file from the report data"""
        output = io.StringIO()
        
        # Get columns
        columns = self.get_columns()
        
        # Create CSV writer and write headers
        writer = csv.DictWriter(output, fieldnames=columns)
        writer.writeheader()
        
        # Write data rows
        for row in self.data:
            # Convert any non-string values to strings
            formatted_row = {}
            for col, value in row.items():
                if isinstance(value, datetime):
                    formatted_row[col] = value.strftime('%Y-%m-%d %H:%M:%S')
                elif value is None:
                    formatted_row[col] = ''
                else:
                    formatted_row[col] = value
            writer.writerow(formatted_row)
        
        return io.BytesIO(output.getvalue().encode('utf-8'))


class HTMLFormatter(BaseFormatter):
    """Format report data as an HTML page"""
    
    def get_http_response(self):
        html_content = self.get_rendered_template()
        return HttpResponse(html_content)
    
    def get_file(self):
        """Generate an HTML file from the report data"""
        html_content = self.get_rendered_template()
        output = io.BytesIO(html_content.encode('utf-8'))
        return output
    
    def get_rendered_template(self):
        """Render the HTML template with the report data"""
        template = get_template('reporting/report_html_output.html')
        
        # Convert column names from snake_case to Title Case for display
        columns = self.get_columns()
        display_columns = [col.replace('_', ' ').title() for col in columns]
        
        context = {
            'report': self.report,
            'data': self.data,
            'metadata': self.metadata,
            'columns': columns,
            'display_columns': display_columns,
        }
        
        return template.render(context)


class PDFFormatter(BaseFormatter):
    """Format report data as a PDF file"""
    
    def get_http_response(self):
        pdf_content = self.get_file().getvalue()
        response = HttpResponse(pdf_content, content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{self.filename}.pdf"'
        return response
    
    def get_file(self):
        """Generate a PDF file from the report data"""
        # First, get the HTML content
        html_formatter = HTMLFormatter(self.report, {'data': self.data, 'metadata': self.metadata})
        html_content = html_formatter.get_rendered_template()
        
        # Create a temporary file to store the HTML content
        with tempfile.NamedTemporaryFile(suffix='.html', delete=False) as temp_html:
            temp_html.write(html_content.encode('utf-8'))
            temp_html_path = temp_html.name
        
        try:
            # Use WeasyPrint to convert HTML to PDF
            pdf_output = io.BytesIO()
            HTML(string=html_content).write_pdf(pdf_output)
            pdf_output.seek(0)
            return pdf_output
        except Exception as e:
            logger.error(f"Error generating PDF: {e}")
            # Fallback to pdfkit if WeasyPrint fails
            try:
                pdf_content = pdfkit.from_string(html_content, False)
                return io.BytesIO(pdf_content)
            except Exception as e2:
                logger.error(f"PDF fallback also failed: {e2}")
                raise
        finally:
            # Clean up the temporary file
            try:
                os.unlink(temp_html_path)
            except:
                pass


class WordDocFormatter(BaseFormatter):
    """Format report data as a Word document"""
    
    def get_http_response(self):
        docx_content = self.get_file().getvalue()
        response = HttpResponse(
            docx_content, 
            content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
        response['Content-Disposition'] = f'attachment; filename="{self.filename}.docx"'
        return response
    
    def get_file(self):
        """Generate a Word document from the report data"""
        try:
            from docx import Document
            from docx.shared import Pt, Inches
            
            # Create a new document
            doc = Document()
            
            # Add title
            doc.add_heading(self.report.name, level=1)
            
            # Add metadata
            doc.add_paragraph(f"Generated: {self.metadata.get('generated_at')}")
            doc.add_paragraph(f"Generated by: {self.metadata.get('generated_by')}")
            doc.add_paragraph()  # Blank line
            
            # Add table
            columns = self.get_columns()
            if not columns:
                doc.add_paragraph("No data to display")
                output = io.BytesIO()
                doc.save(output)
                output.seek(0)
                return output
            
            # Create table with header row
            table = doc.add_table(rows=1, cols=len(columns))
            table.style = 'Table Grid'
            
            # Add header row
            header_cells = table.rows[0].cells
            for i, column in enumerate(columns):
                header_cells[i].text = column.replace('_', ' ').title()
            
            # Add data rows
            for data_row in self.data:
                row_cells = table.add_row().cells
                for i, column in enumerate(columns):
                    value = data_row.get(column, '')
                    row_cells[i].text = str(value) if value is not None else ''
            
            # Auto-adjust column widths
            for cell in table.columns:
                cell.width = Inches(1.5)
            
            # Save to memory
            output = io.BytesIO()
            doc.save(output)
            output.seek(0)
            return output
            
        except ImportError:
            logger.error("python-docx library is required for Word document formatting")
            raise


class JSONFormatter(BaseFormatter):
    """Format report data as a JSON file"""
    
    def get_http_response(self):
        json_content = self.get_file().getvalue()
        response = HttpResponse(json_content, content_type='application/json')
        response['Content-Disposition'] = f'attachment; filename="{self.filename}.json"'
        return response
    
    def get_file(self):
        """Generate a JSON file from the report data"""
        # Convert datetime objects to strings
        data = []
        for row in self.data:
            formatted_row = {}
            for key, value in row.items():
                if isinstance(value, datetime):
                    formatted_row[key] = value.isoformat()
                else:
                    formatted_row[key] = value
            data.append(formatted_row)
        
        # Create the output JSON
        output_data = {
            'report': {
                'name': self.report.name,
                'description': self.report.description,
            },
            'metadata': self.metadata,
            'data': data
        }
        
        # Serialize to JSON
        json_content = json.dumps(output_data, indent=2)
        return io.BytesIO(json_content.encode('utf-8'))


# Factory function to create the appropriate formatter
def get_formatter(format_type, report_def, report_data):
    """Factory function to get the appropriate formatter"""
    formatters = {
        'excel': ExcelFormatter,
        'csv': CSVFormatter,
        'html': HTMLFormatter,
        'pdf': PDFFormatter,
        'word': WordDocFormatter,
        'json': JSONFormatter,
    }
    
    formatter_class = formatters.get(format_type.lower())
    if not formatter_class:
        raise ValueError(f"Unsupported format type: {format_type}")
    
    return formatter_class(report_def, report_data)