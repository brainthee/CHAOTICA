from django.core.exceptions import ValidationError
from django.db.models import Q, Sum
from django.db import models
from django.contrib.auth.models import AbstractUser
from pprint import pprint
from django.templatetags.static import static
import uuid, os, random
from .managers import SystemNoteManager
from .enums import *
from jobtracker.enums import UserSkillRatings
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
import django.contrib.auth
from decimal import *
from django.utils import timezone
from datetime import timedelta
from dateutil.relativedelta import *
from phonenumber_field.modelfields import PhoneNumberField
from django_countries.fields import CountryField
from django.contrib.postgres.fields import ArrayField
from .tasks import task_send_notifications
from jobtracker.enums import TimeSlotType


def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]


class Note(models.Model):
    create_date = models.DateTimeField(verbose_name="Created", auto_now_add=True, help_text="Date the record was created")
    mod_date = models.DateTimeField(verbose_name="Last Modified", auto_now=True, help_text="Date the record was last modified")
    history = HistoricalRecords()
    content = models.TextField(verbose_name="Content", null=True, blank=True, help_text="Note Text")
    author = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET(get_sentinel_user),)
    is_system_note = models.BooleanField(default=False, help_text="Is the note generated by the system", verbose_name="System Note")
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ['-create_date']


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=255, default="")
    icon = models.CharField(max_length=255, null=True, blank=True, default="")
    message = models.TextField(default="")
    link = models.URLField(blank=True, null=True)
    is_read = models.BooleanField(default=False)

    class Meta:
        ordering = ['-timestamp']


class Group(django.contrib.auth.models.Group):

    class Meta:
        proxy = True

    def getGlobalRoleINT(self):
        # If we're a global role group... return the int value
        for role in GlobalRoles.CHOICES:
            nameToCheck = settings.GLOBAL_GROUP_PREFIX+role[1]
            if self.name == nameToCheck:
                return role[0]
        return None

    def role_bs_colour(self):
        val = self.getGlobalRoleINT()
        if val != None:
            return GlobalRoles.BS_COLOURS[val][1]
        else:
            return ""
        
def get_media_image_file_path(instance, filename):
    ext = filename.split('.')[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join('media/images', filename)

class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = ['display_name']
        unique_together = ['lang_code', 'display_name']

    def __str__(self):
        return '{}'.format(self.display_name)


class User(AbstractUser):
    manager = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="users_managed", null=True, blank=True)
    acting_manager = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="users_acting_managed", null=True, blank=True)
    job_title = models.CharField(verbose_name="Job Title", max_length=255, null=True, blank=True, default="")
    location = models.CharField(verbose_name="Location", max_length=255, null=True, blank=True, default="")
    external_id = models.CharField(verbose_name="External ID", db_index=True, max_length=255, null=True, blank=True, default="")
    phone_number = PhoneNumberField(blank=True)
    show_help = models.BooleanField(verbose_name="Show Tips", help_text="Should help be shown", default=True)
    site_theme = models.CharField(verbose_name="Site Theme", max_length=20, default="light")
    schedule_feed_id = models.UUIDField(verbose_name="Calendar Feed Key", default=uuid.uuid4)
    groups = models.ManyToManyField(Group, verbose_name='groups',
        blank=True, help_text='The groups this user belongs to. A user will '
                                'get all permissions granted to each of '
                                'their groups.',
        related_name="user_set", related_query_name="user")
    languages = models.ManyToManyField(Language, verbose_name='Languages', blank=True)
    profile_image = models.ImageField(default='default.jpg',  
                                     upload_to=get_media_image_file_path,)
    
    class Meta:
        ordering = ['last_name']

    def get_avatar_url(self):
        if self.profile_image:
            return self.profile_image.url
        else:
            rand = random.randint(1,5)
            return static('assets/img/team-{}.jpg'.format(rand))
    
    def get_current_status(self):
        # online, offline, away, do-not-disturb
        # Used to decorate avatars
        return "online"
    
    def get_timeslots(self, start=None, end=None):
        from jobtracker.models import TimeSlot
        data = []

        today = timezone.now().today()
        start_of_week = today - timedelta(days = today.weekday())
        end_of_week = start_of_week + timedelta(days = 6)
        start = start or start_of_week
        end = end or end_of_week

        slots = TimeSlot.objects.filter(user=self, start__gte=start, start__lte=end)
        for slot in slots:
            data.append(slot.get_web_schedule_format())
        return data
    
    def is_people_manager(self):
        if self.users_managed.exists() or self.users_acting_managed.exists():
            return True
        else:
            return False

    def save(self, *args, **kwargs):
        # Lets check if we're the only user...
        if User.objects.all().count() == 1:
            # We're the first real user. Bump us to superuser
            self.is_superuser = True
            self.is_staff = True
            super().save(*args, **kwargs)
            # Make sure they are a global admin too!
            gAdmin, created = Group.objects.get_or_create(name=settings.GLOBAL_GROUP_PREFIX+GlobalRoles.CHOICES[GlobalRoles.ADMIN][1])
            self.groups.add(gAdmin)
        return super().save(*args, **kwargs)
    
    def get_skills_specialist(self):
        return self.skills.filter(rating=UserSkillRatings.SPECIALIST)
    
    def get_skills_alone(self):
        return self.skills.filter(rating=UserSkillRatings.CAN_DO_ALONE)
    
    def get_skills_support(self):
        return self.skills.filter(rating=UserSkillRatings.CAN_DO_WITH_SUPPORT)
    
    def __str__(self):
        if self.first_name and self.last_name:
            return '{} {}'.format(self.first_name, self.last_name)
        else:
            return '{}'.format(self.username)

    def get_average_techqa_feedback_tech(self, fromRange=None, toRange=None):
        myReports = self.phase_where_report_author.all()
        totalReports = 0
        totalScore = 0
        if not toRange:
            # Set to today
            toRange = timezone.now().today().date()
        if not fromRange:
            # Set to previous 12m
            fromRange = toRange - relativedelta(months=12)
        for report in myReports:
            # check we've got rating!
            if report.techqa_report_rating and report.presqa_report_rating:
                # Check if in range
                if report.delivery_date:
                    if report.delivery_date > fromRange or fromRange == None:
                        if report.delivery_date < toRange or toRange == None:
                            # Include it!
                            totalReports += 1
                            totalScore = totalScore + report.techqa_report_rating
        if totalReports > 0:
            return totalScore / totalReports
        else:
            return 0
        
    def get_average_techqa_feedback_tech_12mo(self):
        # Get the last 12 months of tech feedback
        months = []
        data = []
        today = timezone.now().today()
        for i in range(12,0, -1):
            month = today-relativedelta(months=i)
            month = month+relativedelta(day=1)
            months.append(str(month.date()))
            data.append(random.randint(0,5))

        return {
            'months': months,
            'data': data,
        }
    
    def get_absolute_url(self):
        if self.email:
            return reverse('user_profile', kwargs={'username': self.username})
        else:
            return None
    
    def current_cost(self):
        if self.costs.all().exists():
            return self.costs.all().last()
        else:
            return None
    
    def update_cost(self, cost):
        self.update_cost(self, cost, timezone.today())
    
    def update_cost(self, cost, effectiveFrom):
        return UserCost.objects.create(user=self, effective_from=effectiveFrom, cost_per_hour=cost)


class UserCost(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="costs")
    effective_from = models.DateField(verbose_name="Effective From", null=True, blank=True, help_text="Date cost applies from")
    cost_per_hour = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True,
        verbose_name="Cost Per Hour", help_text="Cost of the user per hour")

    class Meta:
        ordering = ['user', '-effective_from']
        unique_together = ['user', 'effective_from']
    
    def __str__(self):
        return '{} {}'.format(str(self.user), str(self.cost_per_hour))


class HolidayCountry(models.Model):
    country = CountryField()

    class Meta:
        ordering = ['country',]
    
    def __str__(self):
        return '{}'.format(str(self.country.name))


class Holiday(models.Model):
    date = models.DateField(db_index=True)
    country = models.ForeignKey(HolidayCountry, on_delete=models.CASCADE)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        return '{} ({})'.format(str(self.reason), str(self.country))

    class Meta:
        ordering = ['-date',]
        unique_together = ['date', 'country', 'reason']



class LeaveRequest(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="leave_records")
    
    requested_on = models.DateTimeField(auto_now_add=True)
    start_date = models.DateTimeField(db_index=True)
    end_date = models.DateTimeField(db_index=True)

    type_of_leave = models.IntegerField(choices=LeaveRequestTypes.CHOICES)
    notes = models.TextField(null=True, blank=True)

    authorised = models.BooleanField(default=False)
    authorised_on = models.DateTimeField(null=True, blank=True)
    authorised_by = models.ForeignKey(settings.AUTH_USER_MODEL,
        related_name='leave_records_authorised',
        null=True, blank=True,
        on_delete=models.PROTECT,
    )

    timeslot = models.ForeignKey('jobtracker.TimeSlot', null=True, blank=True, on_delete=models.CASCADE)

    cancelled = models.BooleanField(default=False)
    cancelled_on = models.DateTimeField(null=True, blank=True)

    declined = models.BooleanField(default=False)
    declined_on = models.DateTimeField(null=True, blank=True)
    declined_by = models.ForeignKey(settings.AUTH_USER_MODEL,
        related_name='leave_records_declined',
        null=True, blank=True,
        on_delete=models.PROTECT,
    )

    def requested_late(self):
        return self.start_date < (self.requested_on + timedelta(days=settings.LEAVE_DAYS_NOTICE))
    
    def can_approve_by(self):
        # Update to reflect logic...
        userPKs = []
        if self.user.manager:
            userPKs.append(self.user.manager.pk)
        if self.user.acting_manager:
            userPKs.append(self.user.acting_manager.pk)
        
        if not userPKs:
            # No managers - lets default to unit managers...
            for membership in self.user.unit_memberships.all():
                userPKs.append(membership.unit.get_active_members_with_perm("can_approve_leave_requests").values_list('pk', flat=True))
        return User.objects.filter(pk__in=userPKs).distinct()
    
    def can_user_auth(self, user):
        return user in self.can_approve_by()
    
    def send_request_notification(self):
        from .utils import AppNotification
        # Send a notice to... people?!
        users_to_notify = self.can_approve_by()
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Requested - Please review", 
            str(self.user)+" has requested leave. Please review the request", 
            "emails/leave_auth.html", leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_approved_notification(self):
        from .utils import AppNotification
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Approved", 
            "Your leave has been approved!",
            "emails/leave_approved.html", leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_declined_notification(self):
        from .utils import AppNotification
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave DECLINED", 
            "Your leave has been declined. Please contact "+str(self.declined_by)+" for information.",
            "emails/leave_declined.html", leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_cancelled_notification(self):
        from .utils import AppNotification
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Cancelled", 
            "You have cancelled your leave.",
            "emails/leave_cancelled.html", leave=self)
        task_send_notifications.delay(notice, users_to_notify)
    

    def authorise(self, approved_by):
        from jobtracker.models.timeslot import TimeSlot
        if self.cancelled:
            # Can't auth at this stage
            return False
        if not self.authorised:
            # Set our important fields
            self.authorised = True
            self.authorised_by = approved_by
            self.authorised_on = timezone.now()
            self.save()
            # Lets add the timeslot...
            ts, created = TimeSlot.objects.get_or_create(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE
            )
            self.send_approved_notification()
    

    def decline(self, declined_by):
        from jobtracker.models.timeslot import TimeSlot
        if self.authorised or self.cancelled:
            # Can't decline at this stage
            return False
        if not self.declined:
            # Set our important fields
            self.declined = True
            self.declined_by = declined_by
            self.declined_on = timezone.now()
            self.save()
            self.send_declined_notification()

    
    def cancel(self):
        from jobtracker.models.timeslot import TimeSlot
        if not self.cancelled:
            # Set our important fields
            self.cancelled = True
            self.cancelled_on = timezone.now()
            self.authorised = False
            self.declined = False
            self.save()
            # Lets delete the timeslot...
            if TimeSlot.objects.filter(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE).exists():
                TimeSlot.objects.filter(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE).delete()
            self.send_cancelled_notification()
