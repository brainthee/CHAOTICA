from django.core.exceptions import ValidationError
from django.db.models import Q, Sum
from django.db import models
from django.contrib.auth.models import AbstractUser
from pprint import pprint
from django.templatetags.static import static
import uuid, os, random
from .managers import SystemNoteManager
from .enums import *
from jobtracker.enums import UserSkillRatings
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
import django.contrib.auth
from guardian.shortcuts import get_objects_for_user
import inspect

from decimal import *
from django.utils import timezone
from datetime import timedelta, time, date
from dateutil.relativedelta import *
from phonenumber_field.modelfields import PhoneNumberField
from django_countries.fields import CountryField
from django.contrib.postgres.fields import ArrayField
from .tasks import task_send_notifications
from jobtracker.enums import TimeSlotType
from business_duration import businessDuration


def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]


class Note(models.Model):
    create_date = models.DateTimeField(verbose_name="Created", auto_now_add=True, help_text="Date the record was created")
    mod_date = models.DateTimeField(verbose_name="Last Modified", auto_now=True, help_text="Date the record was last modified")
    history = HistoricalRecords()
    content = models.TextField(verbose_name="Content", null=True, blank=True, help_text="Note Text")
    author = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET(get_sentinel_user),)
    is_system_note = models.BooleanField(default=False, help_text="Is the note generated by the system", verbose_name="System Note")
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ['-create_date']


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=255, default="")
    icon = models.CharField(max_length=255, null=True, blank=True, default="")
    message = models.TextField(default="")
    link = models.URLField(blank=True, null=True)
    is_read = models.BooleanField(default=False)

    class Meta:
        ordering = ['-timestamp']


class Group(django.contrib.auth.models.Group):

    class Meta:
        proxy = True

    def getGlobalRoleINT(self):
        # If we're a global role group... return the int value
        for role in GlobalRoles.CHOICES:
            nameToCheck = settings.GLOBAL_GROUP_PREFIX+role[1]
            if self.name == nameToCheck:
                return role[0]
        return None

    def role_bs_colour(self):
        val = self.getGlobalRoleINT()
        if val != None:
            return GlobalRoles.BS_COLOURS[val][1]
        else:
            return ""
        
def get_media_image_file_path(instance, filename):
    ext = filename.split('.')[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join('media/images', filename)

class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = ['display_name']
        unique_together = ['lang_code', 'display_name']

    def __str__(self):
        return '{}'.format(self.display_name)


class User(AbstractUser):
    manager = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="users_managed", null=True, blank=True)
    acting_manager = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="users_acting_managed", null=True, blank=True)
    job_title = models.CharField(verbose_name="Job Title", max_length=255, null=True, blank=True, default="")
    location = models.CharField(verbose_name="Location", max_length=255, null=True, blank=True, default="")
    external_id = models.CharField(verbose_name="External ID", db_index=True, max_length=255, null=True, blank=True, default="")
    phone_number = PhoneNumberField(blank=True)
    show_help = models.BooleanField(verbose_name="Show Tips", help_text="Should help be shown", default=True)
    site_theme = models.CharField(verbose_name="Site Theme", max_length=20, default="light")
    schedule_feed_id = models.UUIDField(verbose_name="Calendar Feed Key", default=uuid.uuid4)
    schedule_feed_family_id = models.UUIDField(verbose_name="Calendar Feed Family Key", default=uuid.uuid4)
    groups = models.ManyToManyField(Group, verbose_name='groups',
            blank=True, help_text='The groups this user belongs to. A user will '
                                    'get all permissions granted to each of '
                                    'their groups.',
            related_name="user_set", related_query_name="user")
    languages = models.ManyToManyField(Language, verbose_name='Languages', blank=True)
    profile_image = models.ImageField(default='default.jpg',  
                                     upload_to=get_media_image_file_path,)
    contracted_leave = models.IntegerField(verbose_name="Contracted Leave", default=0)
    contracted_leave_renewal = models.DateField(verbose_name="Contracted Leave", default=date(day=1, month=9, year=2023))
    
    class Meta:
        ordering = ['last_name']

    def can_scope(self):
        from jobtracker.models.orgunit import OrganisationalUnit
        return get_objects_for_user(self, "can_scope_jobs", OrganisationalUnit)
    
    def can_signoff_scope(self):
        from jobtracker.models.orgunit import OrganisationalUnit
        return get_objects_for_user(self, "can_signoff_scopes", OrganisationalUnit)

    def _get_last_leave_renewal_date(self):
        today = timezone.now().date()
        renewalDate = self.contracted_leave_renewal.replace(year=today.year)
        if renewalDate < today:
            return renewalDate
        else:
            return renewalDate.replace(year=today.year-1)

    def _get_next_leave_renewal_date(self):
        today = timezone.now().date()
        renewalDate = self.contracted_leave_renewal.replace(year=today.year)
        if renewalDate > today:
            return renewalDate
        else:
            return renewalDate.replace(year=today.year+1)
    
    def remaining_leave(self):
        return self.contracted_leave - self.pending_leave() - self.used_leave()

    def pending_leave(self):
        total = 0
        for leave in LeaveRequest.objects.filter(
            user=self, cancelled=False, authorised=True, 
            start_date__gte=self._get_last_leave_renewal_date(),
            end_date__lte=self._get_next_leave_renewal_date()).filter(
            start_date__gte=timezone.now()):
            total = total + leave.affected_days()
        return total

    def used_leave(self):
        total = 0
        for leave in LeaveRequest.objects.filter(
            user=self, cancelled=False, authorised=True, 
            start_date__gte=self._get_last_leave_renewal_date(),
            end_date__lte=self._get_next_leave_renewal_date()).filter(
            start_date__lte=timezone.now(),
            end_date__lte=timezone.now()):
            total = total + leave.affected_days()
        return total
    
    def unread_notifications(self):
        return Notification.objects.filter(user=self, is_read=False)

    def get_avatar_url(self):
        if self.profile_image:
            return self.profile_image.url
        else:
            rand = random.randint(1,5)
            return static('assets/img/team-{}.jpg'.format(rand))
    
    def get_current_status(self):
        # online, offline, away, do-not-disturb
        # Used to decorate avatars
        return "online"
    
    def get_timeslots(self, start=None, end=None):
        from jobtracker.models import TimeSlot
        data = []

        today = timezone.now().today()
        start_of_week = today - timedelta(days = today.weekday())
        end_of_week = start_of_week + timedelta(days = 6)
        start = start or start_of_week
        end = end or end_of_week

        slots = TimeSlot.objects.filter(user=self, start__gte=start, start__lte=end)
        for slot in slots:
            data.append(slot.get_web_schedule_format())
        return data
    
    def is_people_manager(self):
        if self.users_managed.exists() or self.users_acting_managed.exists():
            return True
        else:
            return False

    def save(self, *args, **kwargs):
        # Lets check if we're the only user...
        if User.objects.all().count() == 1:
            # We're the first real user. Bump us to superuser
            self.is_superuser = True
            self.is_staff = True
            super().save(*args, **kwargs)
            # Make sure they are a global admin too!
            gAdmin, created = Group.objects.get_or_create(name=settings.GLOBAL_GROUP_PREFIX+GlobalRoles.CHOICES[GlobalRoles.ADMIN][1])
            self.groups.add(gAdmin)
        return super().save(*args, **kwargs)
    
    def get_skills_specialist(self):
        return self.skills.filter(rating=UserSkillRatings.SPECIALIST)
    
    def get_skills_alone(self):
        return self.skills.filter(rating=UserSkillRatings.CAN_DO_ALONE)
    
    def get_skills_support(self):
        return self.skills.filter(rating=UserSkillRatings.CAN_DO_WITH_SUPPORT)
    
    def __str__(self):
        if self.first_name and self.last_name:
            return '{} {}'.format(self.first_name, self.last_name)
        else:
            return '{}'.format(self.username)
        
    def get_average_qa_rating(self, qaField, 
                            fromRange=timezone.now() - relativedelta(months=12), 
                            toRange=timezone.now()):
        myReports = self.phase_where_report_author.filter(
            actual_completed_date__gte=fromRange, actual_completed_date__lte=toRange)
        total_reports = myReports.count()
        combined_score = 0
        total_score = 0
        
        for report in myReports:
            # check we've got rating!
            if getattr(report, qaField):
                combined_score = combined_score + int(getattr(report, qaField))

        if total_reports > 0:
            total_score = combined_score / total_reports
        
        return total_score

    def get_average_techqa_feedback_tech(self, 
                                         fromRange=timezone.now() - relativedelta(months=12), 
                                         toRange=timezone.now()):
        return self.get_average_qa_rating("techqa_report_rating", fromRange, toRange)
        

    def get_average_presqa_feedback_tech(self, 
                                         fromRange=timezone.now() - relativedelta(months=12), 
                                         toRange=timezone.now()):
        return self.get_average_qa_rating("presqa_report_rating", fromRange, toRange)
    
        
    def get_average_qa_rating_12mo(self, qaField):
        from chaotica_utils.utils import last_day_of_month
        # Get the last 12 months of tech feedback
        months = []
        data = []
        today = timezone.now()
        for i in range(12,-1, -1):
            month = today-relativedelta(months=i)
            startMonth = month+relativedelta(day=1)
            endMonth = last_day_of_month(startMonth)
            avg = self.get_average_qa_rating(qaField, fromRange=startMonth, toRange=endMonth)
            months.append(str(startMonth.date()))
            data.append(avg)

        data = {
            'months': months,
            'data': data,
        }
        return data
    
        
    def get_average_techqa_feedback_tech_12mo(self):
        return self.get_average_qa_rating_12mo("techqa_report_rating")
    
        
    def get_average_presqa_feedback_tech_12mo(self):
        return self.get_average_qa_rating_12mo("presqa_report_rating")
    
    
    def get_absolute_url(self):
        if self.email:
            return reverse('user_profile', kwargs={'username': self.username})
        else:
            return None
    
    def current_cost(self):
        if self.costs.all().exists():
            return self.costs.all().last()
        else:
            return None
    
    def update_cost(self, cost):
        self.update_cost(self, cost, timezone.today())
    
    def update_cost(self, cost, effectiveFrom):
        return UserCost.objects.create(user=self, effective_from=effectiveFrom, cost_per_hour=cost)


class UserCost(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="costs")
    effective_from = models.DateField(verbose_name="Effective From", null=True, blank=True, help_text="Date cost applies from")
    cost_per_hour = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True,
        verbose_name="Cost Per Hour", help_text="Cost of the user per hour")

    class Meta:
        ordering = ['user', '-effective_from']
        unique_together = ['user', 'effective_from']
    
    def __str__(self):
        return '{} {}'.format(str(self.user), str(self.cost_per_hour))


class HolidayCountry(models.Model):
    country = CountryField()

    class Meta:
        ordering = ['country',]
    
    def __str__(self):
        return '{}'.format(str(self.country.name))


class Holiday(models.Model):
    date = models.DateField(db_index=True)
    country = models.ForeignKey(HolidayCountry, on_delete=models.CASCADE)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        return '{} ({})'.format(str(self.reason), str(self.country))

    class Meta:
        ordering = ['-date',]
        unique_together = ['date', 'country', 'reason']



class LeaveRequest(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET(get_sentinel_user),
                            related_name="leave_records")
    
    requested_on = models.DateTimeField(auto_now_add=True)
    start_date = models.DateTimeField(db_index=True)
    end_date = models.DateTimeField(db_index=True)

    type_of_leave = models.IntegerField(choices=LeaveRequestTypes.CHOICES)
    notes = models.TextField(null=True, blank=True)

    authorised = models.BooleanField(default=False)
    authorised_on = models.DateTimeField(null=True, blank=True)
    authorised_by = models.ForeignKey(settings.AUTH_USER_MODEL,
        related_name='leave_records_authorised',
        null=True, blank=True,
        on_delete=models.PROTECT,
    )

    timeslot = models.ForeignKey('jobtracker.TimeSlot', null=True, blank=True, on_delete=models.CASCADE)

    cancelled = models.BooleanField(default=False)
    cancelled_on = models.DateTimeField(null=True, blank=True)

    declined = models.BooleanField(default=False)
    declined_on = models.DateTimeField(null=True, blank=True)
    declined_by = models.ForeignKey(settings.AUTH_USER_MODEL,
        related_name='leave_records_declined',
        null=True, blank=True,
        on_delete=models.PROTECT,
    )

    class Meta:
        verbose_name = 'Leave Request'
        ordering = ['start_date']
    
    def overlaps_work(self):
        from jobtracker.models.timeslot import TimeSlot
        return TimeSlot.objects.filter(user=self.user, slotType=TimeSlotType.DELIVERY,
            start__lte=self.end_date,
            end__gte=self.start_date).exists()
    
    def overlaps_confirmed_work(self):
        from jobtracker.models.timeslot import TimeSlot
        from jobtracker.enums import PhaseStatuses
        return TimeSlot.objects.filter(user=self.user, slotType=TimeSlotType.DELIVERY,
            phase__status__gte=PhaseStatuses.SCHEDULED_CONFIRMED, 
            start__lte=self.end_date,
            end__gte=self.start_date).exists()

    def requested_late(self):
        return self.start_date < (self.requested_on + timedelta(days=settings.LEAVE_DAYS_NOTICE))
    
    def affected_days(self):
        # startbday = time(9,0,0)
        # endbday = time(16,30,0) # 5:30pm - 1hr for lunch! :) 
        unit='day'
        days = businessDuration(self.start_date, self.end_date, unit=unit)
        return round(days, 2)
    
    def can_cancel(self):
        # Only situ we can't cancel is if it's in the past or it's already cancelled.
        if self.start_date < timezone.now():
            return False
        if self.cancelled:
            return False
        return True
    
    def can_approve_by(self):
        # Update to reflect logic...
        userPKs = []
        if self.user.manager:
            userPKs.append(self.user.manager.pk)
        if self.user.acting_manager:
            userPKs.append(self.user.acting_manager.pk)
        
        if not userPKs:
            # No managers - lets default to unit managers...
            for membership in self.user.unit_memberships.all():
                userPKs.append(membership.unit.get_active_members_with_perm("can_approve_leave_requests").values_list('pk', flat=True))
        return User.objects.filter(pk__in=userPKs).distinct()
    
    def can_user_auth(self, user):
        if self.cancelled:
            return False
        return user in self.can_approve_by()
    
    def send_request_notification(self):
        from .utils import AppNotification, ext_reverse
        # Send a notice to... people?!
        users_to_notify = self.can_approve_by()
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Requested - Please review", 
            str(self.user)+" has requested leave. Please review the request", 
            "emails/leave.html", action_link=ext_reverse(reverse('manage_leave')), leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_approved_notification(self):
        from .utils import AppNotification, ext_reverse
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Approved", 
            "Your leave has been approved!",
            "emails/leave.html", action_link=ext_reverse(reverse('view_own_leave')), leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_declined_notification(self):
        from .utils import AppNotification, ext_reverse
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave DECLINED", 
            "Your leave has been declined. Please contact "+str(self.declined_by)+" for information.",
            "emails/leave.html", action_link=ext_reverse(reverse('view_own_leave')), leave=self)
        task_send_notifications.delay(notice, users_to_notify)

    
    def send_cancelled_notification(self):
        from .utils import AppNotification, ext_reverse
        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE, 
            "Leave Cancelled", 
            "You have cancelled your leave.",
            "emails/leave.html", action_link=ext_reverse(reverse('view_own_leave')), leave=self)
        task_send_notifications.delay(notice, users_to_notify)
    

    def authorise(self, approved_by):
        from jobtracker.models.timeslot import TimeSlot
        if self.cancelled:
            # Can't auth at this stage
            return False
        if not self.authorised:
            # Set our important fields
            self.authorised = True
            self.authorised_by = approved_by
            self.authorised_on = timezone.now()
            self.save()
            # Lets add the timeslot...
            ts, created = TimeSlot.objects.get_or_create(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE
            )
            self.send_approved_notification()
    

    def decline(self, declined_by):
        from jobtracker.models.timeslot import TimeSlot
        if self.authorised or self.cancelled:
            # Can't decline at this stage
            return False
        if not self.declined:
            # Set our important fields
            self.declined = True
            self.declined_by = declined_by
            self.declined_on = timezone.now()
            self.save()
            self.send_declined_notification()

    
    def cancel(self):
        from jobtracker.models.timeslot import TimeSlot
        if not self.cancelled:
            # Set our important fields
            self.cancelled = True
            self.cancelled_on = timezone.now()
            self.authorised = False
            self.declined = False
            self.save()
            # Lets delete the timeslot...
            if TimeSlot.objects.filter(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE).exists():
                TimeSlot.objects.filter(
                user=self.user, start=self.start_date, end=self.end_date,
                slotType=TimeSlotType.LEAVE).delete()
            self.send_cancelled_notification()
