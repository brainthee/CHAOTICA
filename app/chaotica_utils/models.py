from django.db import models
from django.contrib.auth.models import AbstractUser, Permission
from django.templatetags.static import static
import uuid
import os
from .managers import SystemNoteManager
from .enums import GlobalRoles, LeaveRequestTypes, NotificationTypes
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.db.models import Q
from django.urls import reverse
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
import django.contrib.auth
from guardian.shortcuts import get_objects_for_user, assign_perm
from django.utils import timezone
from datetime import timedelta, date
from dateutil.relativedelta import relativedelta
from django.db.models.functions import Lower
from phonenumber_field.modelfields import PhoneNumberField
from django_countries.fields import CountryField
from .tasks import task_send_notifications
from jobtracker.enums import DefaultTimeSlotTypes, UserSkillRatings
from business_duration import businessDuration
from constance import config
from django.template.loader import render_to_string
from django.core.mail import send_mail


def get_sentinel_user():
    return get_user_model().objects.get_or_create(email="deleted@chaotica.app")[0]


class Note(models.Model):
    create_date = models.DateTimeField(
        verbose_name="Created",
        auto_now_add=True,
        help_text="Date the record was created",
    )
    mod_date = models.DateTimeField(
        verbose_name="Last Modified",
        auto_now=True,
        help_text="Date the record was last modified",
    )
    history = HistoricalRecords()
    content = models.TextField(
        verbose_name="Content", blank=True, help_text="Note Text"
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )
    is_system_note = models.BooleanField(
        default=False,
        help_text="Is the note generated by the system",
        verbose_name="System Note",
    )
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ["-create_date"]


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=255, default="")
    icon = models.CharField(max_length=255, blank=True, null=True, default="")
    message = models.TextField(default="")
    link = models.URLField(blank=True, null=True)
    is_read = models.BooleanField(default=False)
    email_template = models.CharField(max_length=255, default="")
    is_emailed = models.BooleanField(default=False)

    class Meta:
        ordering = ["-timestamp"]

    def send_email(self):
        if self.user.is_active() and config.EMAIL_ENABLED:
            context = {}
            context["SITE_DOMAIN"] = settings.SITE_DOMAIN
            context["SITE_PROTO"] = settings.SITE_PROTO
            context["title"] = self.title
            context["message"] = self.message
            context["icon"] = self.icon
            context["action_link"] = self.link
            context["user"] = self.user
            msg_html = render_to_string(self.email_template, context)
            if (
                send_mail(
                    self.title,
                    self.message,
                    None,
                    [self.user.email_address()],
                    html_message=msg_html,
                )
                > 0
            ):
                self.is_emailed = True
                self.save()
        else:
            # User or site disabled, don't send emails
            self.is_emailed = True
            self.save()


class Group(django.contrib.auth.models.Group):

    class Meta:
        proxy = True

    def getGlobalRoleINT(self):
        # If we're a global role group... return the int value
        for role in GlobalRoles.CHOICES:
            name_to_check = settings.GLOBAL_GROUP_PREFIX + role[1]
            if self.name == name_to_check:
                return role[0]
        return None

    def role_bs_colour(self):
        val = self.getGlobalRoleINT()
        if val != None:
            return GlobalRoles.BS_COLOURS[val][1]
        else:
            return ""

    def sync_global_permissions(self):
        for global_role in GlobalRoles.CHOICES:
            if self.name == settings.GLOBAL_GROUP_PREFIX + global_role[1]:
                # Ok, we match a global role..
                self.permissions.clear()
                for perm in GlobalRoles.PERMISSIONS[global_role[0]][1]:  # how ugly!
                    try:
                        assign_perm(perm, self, None)
                    except Permission.DoesNotExist:
                        pass  # ignore this for the moment!
                return True

        # If we reach this; this group isn't matched with a global role in code
        return False


def get_media_profile_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("profile_pics", filename)


def get_media_image_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("images", filename)


class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = [Lower("display_name")]
        unique_together = ["lang_code", "display_name"]

    def __str__(self):
        return "{}".format(self.display_name)


class UserInvitation(models.Model):
    invited_email = models.EmailField(
        verbose_name="Email Address", max_length=255, unique=True
    )
    accepted = models.BooleanField(
        verbose_name="Accepted",
        help_text="Has the invitation been accepted",
        default=False,
    )
    invite_id = models.UUIDField(verbose_name="Invitation ID", default=uuid.uuid4)
    sent = models.DateTimeField(null=True, blank=True)
    invited_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name="users_invited",
        null=True,
        blank=True,
        on_delete=models.PROTECT,
    )

    def is_expired(self):
        return self.expiry_date() <= timezone.now()

    def expiry_date(self):
        expiry_date = self.sent + timedelta(days=config.USER_INVITE_EXPIRY)
        return expiry_date

    def get_absolute_url(self):
        return reverse("signup", kwargs={"invite_id": self.invite_id})

    def send_email(self):
        from .utils import ext_reverse

        if config.EMAIL_ENABLED:
            ## Email notification
            context = {}
            context["SITE_DOMAIN"] = settings.SITE_DOMAIN
            context["SITE_PROTO"] = settings.SITE_PROTO
            context["title"] = "You're invited to Chaotica"
            context["message"] = (
                "You've been invited to join Chaotica - (Centralised Hub for Assigning Operational Tasks, Interactive Calendaring and Alerts). Follow the link below to accept the invitation and setup your account."
            )
            context["action_link"] = ext_reverse(self.get_absolute_url())
            msg_html = render_to_string("emails/user_invite.html", context)
            send_mail(
                context["title"],
                context["message"],
                None,
                [self.invited_email],
                html_message=msg_html,
            )

            self.sent = timezone.now()
            self.save()


class User(AbstractUser):
    # Fields to enforce email as the auth field
    username = None
    email = models.EmailField(
        "Email Address",
        unique=True,
        help_text="This is your authenticated email and can not be changed",
    )
    notification_email = models.EmailField(
        "Notification Email Address",
        blank=True,
        default="",
        help_text="If configured, email notifications go to this address rather than your account address.",
    )
    USERNAME_FIELD = "email"
    EMAIL_FIELD = "email"
    REQUIRED_FIELDS = []

    manager = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET(get_sentinel_user),
        related_name="users_managed",
        null=True,
        blank=True,
    )
    acting_manager = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET(get_sentinel_user),
        related_name="users_acting_managed",
        null=True,
        blank=True,
    )
    pref_timezone = models.CharField(
        verbose_name="Time Zone", max_length=255, null=True, blank=True, default="UTC"
    )
    job_title = models.CharField(
        verbose_name="Job Title", max_length=255, null=True, blank=True, default=""
    )
    location = models.CharField(
        verbose_name="Location", max_length=255, null=True, blank=True, default=""
    )
    country = CountryField(default="GB")
    external_id = models.CharField(
        verbose_name="External ID",
        db_index=True,
        max_length=255,
        null=True,
        blank=True,
        default="",
    )
    phone_number = PhoneNumberField(blank=True)
    show_help = models.BooleanField(
        verbose_name="Show Helpful Tips", help_text="Should help be shown", default=True
    )
    site_theme = models.CharField(
        verbose_name="Site Theme", max_length=20, default="light"
    )
    schedule_feed_id = models.UUIDField(
        verbose_name="Calendar Feed Key", default=uuid.uuid4
    )
    schedule_feed_family_id = models.UUIDField(
        verbose_name="Calendar Feed Family Key", default=uuid.uuid4
    )
    groups = models.ManyToManyField(
        Group,
        verbose_name="groups",
        blank=True,
        help_text="The groups this user belongs to. A user will "
        "get all permissions granted to each of "
        "their groups.",
        related_name="user_set",
        related_query_name="user",
    )
    languages = models.ManyToManyField(Language, verbose_name="Languages", blank=True)
    profile_image = models.ImageField(
        blank=True,
        upload_to=get_media_profile_file_path,
    )
    contracted_leave = models.IntegerField(
        verbose_name="Contracted Leave",
        default=25,
        help_text="Days leave you are entitled to",
    )
    carry_over_leave = models.IntegerField(
        verbose_name="Leave Carried Over",
        default=0,
        help_text="Days leave carried over from previous period",
    )
    contracted_leave_renewal = models.DateField(
        verbose_name="Leave Renewal Date",
        default=date(day=1, month=9, year=2023),
        help_text="Date leave is reset",
    )

    profile_last_updated = models.DateField(
        verbose_name="Profile Last Updated", blank=True, null=True
    )

    class Meta:
        ordering = [Lower("last_name"), Lower("first_name")]
        permissions = (
            ("manage_user", "Can manage the user"),
            ("manage_leave", "Manage leave"),
            ("impersonate_users", "Can impersonate other users"),
            ("manage_site_settings", "Can change site settings"),
            ("view_activity_logs", "Can review the activity logs"),
        )

    def merge(self, user_to_merge):
        # Things to merge:
        # Timeslots
        # Leave
        # Job, Phase assignments
        # Org Unit memberships/roles
        # Qualifications

        ## Notes
        Note.objects.filter(author=user_to_merge).update(author=self)
        ## Manager
        User.objects.filter(manager=user_to_merge).update(manager=self)
        User.objects.filter(acting_manager=user_to_merge).update(acting_manager=self)
        ## UserCost
        UserCost.objects.filter(user=user_to_merge).update(user=self)
        ## Leave
        LeaveRequest.objects.filter(user=user_to_merge).update(user=self)
        LeaveRequest.objects.filter(authorised_by=user_to_merge).update(
            authorised_by=self
        )
        LeaveRequest.objects.filter(declined_by=user_to_merge).update(declined_by=self)
        ## Client
        from jobtracker.models.client import Client

        for obj in Client.objects.filter(account_managers__in=[user_to_merge]):
            obj.account_managers.remove(user_to_merge)
            obj.account_managers.add(self)
            obj.save()
        for obj in Client.objects.filter(tech_account_managers__in=[user_to_merge]):
            obj.tech_account_managers.remove(user_to_merge)
            obj.tech_account_managers.add(self)
            obj.save()
        for obj in Client.objects.filter(onboarded_users__in=[user_to_merge]):
            obj.onboarded_users.remove(user_to_merge)
            obj.onboarded_users.add(self)
            obj.save()
        ## Feedback
        from jobtracker.models.common import Feedback

        Feedback.objects.filter(author=user_to_merge).update(author=self)
        ## Job
        from jobtracker.models.job import Job

        Job.objects.filter(created_by=user_to_merge).update(created_by=self)
        Job.objects.filter(account_manager=user_to_merge).update(account_manager=self)
        Job.objects.filter(dep_account_manager=user_to_merge).update(
            dep_account_manager=self
        )
        for obj in Job.objects.filter(scoped_by__in=[user_to_merge]):
            obj.scoped_by.remove(user_to_merge)
            obj.scoped_by.add(self)
            obj.save()
        Job.objects.filter(scoped_signed_off_by=user_to_merge).update(
            scoped_signed_off_by=self
        )
        Job.objects.filter(created_by=user_to_merge).update(created_by=self)
        ## JobSupportTeamRole
        from jobtracker.models.job import JobSupportTeamRole

        JobSupportTeamRole.objects.filter(user=user_to_merge).update(user=self)
        ## JobSupportTeamRole
        from jobtracker.models.orgunit import (
            OrganisationalUnit,
            OrganisationalUnitMember,
        )

        OrganisationalUnit.objects.filter(lead=user_to_merge).update(lead=self)
        OrganisationalUnitMember.objects.filter(member=user_to_merge).update(
            member=self
        )
        OrganisationalUnitMember.objects.filter(inviter=user_to_merge).update(
            inviter=self
        )
        ## Phase
        from jobtracker.models.phase import Phase

        Phase.objects.filter(report_author=user_to_merge).update(report_author=self)
        Phase.objects.filter(project_lead=user_to_merge).update(project_lead=self)
        Phase.objects.filter(techqa_by=user_to_merge).update(techqa_by=self)
        Phase.objects.filter(presqa_by=user_to_merge).update(presqa_by=self)
        Phase.objects.filter(last_modified_by=user_to_merge).update(
            last_modified_by=self
        )
        ## Project
        from jobtracker.models.project import Project

        Project.objects.filter(created_by=user_to_merge).update(created_by=self)
        Project.objects.filter(primary_poc=user_to_merge).update(primary_poc=self)
        ## QualificationRecord
        from jobtracker.models.qualification import QualificationRecord

        QualificationRecord.objects.filter(user=user_to_merge).update(user=self)
        ## Service
        from jobtracker.models.service import Service

        for obj in Service.objects.filter(owners__in=[user_to_merge]):
            obj.owners.remove(user_to_merge)
            obj.owners.add(self)
            obj.save()
        ## TimeSlot
        from jobtracker.models.timeslot import TimeSlot

        TimeSlot.objects.filter(user=user_to_merge).update(user=self)

        # If we have got this far... delete the target user!
        user_to_merge.delete()

        return True

    def email_address(self):
        if self.notification_email:
            return self.notification_email
        else:
            return self.email

    def skills_last_updated(self):
        if self.skills.all().count():
            return self.skills.order_by("-last_updated_on").first().last_updated_on
        else:
            return None

    def can_scope(self):
        from jobtracker.models.orgunit import OrganisationalUnit

        return get_objects_for_user(self, "can_scope_jobs", OrganisationalUnit)

    def can_signoff_scope(self):
        from jobtracker.models.orgunit import OrganisationalUnit

        return get_objects_for_user(self, "can_signoff_scopes", OrganisationalUnit)

    def can_tqa(self):
        from jobtracker.models.orgunit import OrganisationalUnit

        return get_objects_for_user(self, "can_tqa_jobs", OrganisationalUnit)

    def can_pqa(self):
        from jobtracker.models.orgunit import OrganisationalUnit

        return get_objects_for_user(self, "can_pqa_jobs", OrganisationalUnit)

    def _get_last_leave_renewal_date(self):
        today = timezone.now().date()
        renewal_date = self.contracted_leave_renewal.replace(year=today.year)
        if renewal_date < today:
            return renewal_date
        else:
            return renewal_date.replace(year=today.year - 1)

    def _get_next_leave_renewal_date(self):
        today = timezone.now().date()
        renewal_date = self.contracted_leave_renewal.replace(year=today.year)
        if renewal_date > today:
            return renewal_date
        else:
            return renewal_date.replace(year=today.year + 1)

    def remaining_leave(self):
        return self.contracted_leave - self.pending_leave() - self.used_leave()

    def pending_leave(self):
        total = 0
        for leave in LeaveRequest.objects.filter(
            user=self,
            type_of_leave__in=LeaveRequestTypes.COUNT_TOWARDS_LEAVE,
            cancelled=False,
            authorised=True,
            start_date__gte=self._get_last_leave_renewal_date(),
            end_date__lte=self._get_next_leave_renewal_date(),
        ).filter(start_date__gte=timezone.now()):
            total = total + leave.affected_days()
        return total

    def used_leave(self):
        total = 0
        for leave in LeaveRequest.objects.filter(
            user=self,
            type_of_leave__in=LeaveRequestTypes.COUNT_TOWARDS_LEAVE,
            cancelled=False,
            authorised=True,
            start_date__gte=self._get_last_leave_renewal_date(),
            end_date__lte=self._get_next_leave_renewal_date(),
        ).filter(start_date__lte=timezone.now(), end_date__lte=timezone.now()):
            total = total + leave.affected_days()
        return total

    def unread_notifications(self):
        return Notification.objects.filter(user=self, is_read=False)

    def get_avatar_url(self):
        if self.profile_image:
            return self.profile_image.url
        else:
            return static("assets/img/team/avatar-rounded.webp")

    def get_absolute_url(self):
        if self.email:
            return reverse("user_profile", kwargs={"email": self.email})
        else:
            return None

    def get_manage_url(self):
        if self.email:
            return reverse("user_manage", kwargs={"email": self.email})
        else:
            return None

    def get_table_display_html(self):
        context = {}
        context["u"] = self
        html = render_to_string("partials/users/user_table_display.html", context)
        return html

    def get_profile_card_html(self):
        context = {}
        context["userProfile"] = self
        html = render_to_string("partials/users/user_profile_card.html", context)
        return html

    def get_jobs(self):
        from jobtracker.models import Job

        return Job.objects.jobs_for_user(self)

    def get_timeslot_comments(self, start=None, end=None):
        data = []
        today = timezone.now().today()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)

        start = start or start_of_week
        end = end or end_of_week

        slots = self.timeslot_comments.filter(
            end__gte=start, start__lte=end
        )
        for slot in slots:
            slot_json = slot.get_schedule_json()
            # slot_json["display"] = "background"
            data.append(slot_json)
        return data

    def get_timeslots(self, start=None, end=None, phase_focus=None):
        data = []
        today = timezone.now().today()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)

        start = start or start_of_week
        end = end or end_of_week

        slots = self.timeslots.filter(end__gte=start, start__lte=end)
        for slot in slots:
            slot_json = slot.get_schedule_json()
            is_focused = False
            if phase_focus:
                if slot.phase:
                    if slot.phase == phase_focus:
                        is_focused = True
                    if not is_focused and slot.phase.job == phase_focus:
                        is_focused = True
            if phase_focus and not is_focused:
                slot_json["display"] = "background"
            data.append(slot_json)
        return data

    def get_timeslots_objs(self, start=None, end=None, phase_focus=None):
        today = timezone.now().today()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)

        start = start or start_of_week
        end = end or end_of_week

        slots = self.timeslots.filter(end__gte=start, start__lte=end)
        return slots

    def clear_timeslots_in_range(self, start=None, end=None):
        slots = self.get_timeslots_objs(start, end)
        for slot in slots:
            if (
                # First simple scenario, check if the slot simply falls in our range.
                # Action - delete
                slot.start >= start
                and slot.end <= end
            ):
                slot.delete()
            elif (
                # Now find slots that start before our range but finish inside it.
                # Action - change end date to our start.
                slot.start <= start
                and slot.end <= end
            ):
                slot.end = start
                slot.save()
            elif (
                # Now find the op - slots that start in and end after
                # Action - change the start date to our end
                slot.start >= start
                and slot.end > end
            ):
                slot.start = end
                slot.save()
            elif (
                # Now find slots that go right through. Need to create extra ones!
                slot.start < start
                and slot.end > end
            ):
                # Lets get a duplicate ref
                new_slot = self.timeslots.get(pk=slot.pk)
                new_slot.pk = None
                slot.end = start
                new_slot.start = end
                slot.save()
                new_slot.save()
            else:
                raise Exception("Found an edge case to clear schedule")

    def get_holidays(self, start=None, end=None):
        data = []

        today = timezone.now().today()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)

        start = start or start_of_week
        end = end or end_of_week

        slots = Holiday.objects.filter(
            country__country=self.country, date__gte=start.date(), date__lte=end.date()
        )
        for slot in slots:
            data.append(slot.get_schedule_json())
        return data

    def is_people_manager(self):
        if self.users_managed.exists() or self.users_acting_managed.exists():
            return True
        else:
            return False

    def save(self, *args, **kwargs):
        # Lets check if we're the only user...
        if User.objects.all().count() == 1:
            # We're the first real user. Bump us to superuser
            self.is_superuser = True
            self.is_staff = True
            super().save(*args, **kwargs)
            # Make sure they are a global admin too!
            g_admin, _ = Group.objects.get_or_create(
                name=settings.GLOBAL_GROUP_PREFIX
                + GlobalRoles.CHOICES[GlobalRoles.ADMIN][1]
            )
            self.groups.add(g_admin)
        return super().save(*args, **kwargs)

    def services_can_lead(self):
        from jobtracker.models import Service

        return Service.objects.filter(
            Q(skillsRequired__in=self.get_skills_specialist())
            | Q(skillsRequired__in=self.get_skills_alone())
        )

    def services_can_contribute(self):
        from jobtracker.models import Service

        return Service.objects.filter(
            Q(skillsRequired__in=self.get_skills_specialist())
            | Q(skillsRequired__in=self.get_skills_alone())
            | Q(skillsRequired__in=self.get_skills_support())
        )

    def get_skills_specialist(self):
        from jobtracker.models import Skill

        return Skill.objects.filter(
            pk__in=self.skills.filter(rating=UserSkillRatings.SPECIALIST).values(
                "skill"
            )
        ).distinct()

    def get_skills_alone(self):
        from jobtracker.models import Skill

        return Skill.objects.filter(
            pk__in=self.skills.filter(rating=UserSkillRatings.CAN_DO_ALONE).values(
                "skill"
            )
        ).distinct()

    def get_skills_support(self):
        from jobtracker.models import Skill

        return Skill.objects.filter(
            pk__in=self.skills.filter(
                rating=UserSkillRatings.CAN_DO_WITH_SUPPORT
            ).values("skill")
        ).distinct()

    def __str__(self):
        if self.first_name and self.last_name:
            return "{} {}".format(self.first_name, self.last_name)
        else:
            return "{}".format(self.email)

    def get_average_qa_rating(
        self,
        qa_field,
        from_range=timezone.now() - relativedelta(months=12),
        to_range=timezone.now(),
    ):
        my_reports = self.phase_where_report_author.filter(
            actual_completed_date__gte=from_range, actual_completed_date__lte=to_range
        )
        total_reports = 0
        combined_score = 0
        total_score = 0

        for report in my_reports:
            # check we've got rating!
            rating = getattr(report, qa_field)
            if rating:
                combined_score = combined_score + (int(rating))
                total_reports = total_reports + 1

        if total_reports > 0:
            total_score = combined_score / total_reports

        return total_score

    def get_average_techqa_feedback(
        self,
        from_range=timezone.now() - relativedelta(months=12),
        to_range=timezone.now(),
    ):
        return self.get_average_qa_rating("techqa_report_rating", from_range, to_range)

    def get_average_presqa_feedback(
        self,
        from_range=timezone.now() - relativedelta(months=12),
        to_range=timezone.now(),
    ):
        return self.get_average_qa_rating("presqa_report_rating", from_range, to_range)

    def get_average_qa_rating_12mo(self):
        tqa = self.get_average_techqa_feedback_12mo()
        pqa = self.get_average_presqa_feedback_12mo()
        if tqa > 0 and pqa > 0:
            return (tqa + pqa) / 2
        else:
            return 0

    def get_average_qa_rating_12mo(self, qa_field):
        from chaotica_utils.utils import last_day_of_month

        # Get the last 12 months of tech feedback
        months = []
        data = []
        today = timezone.now()
        for i in range(12, -1, -1):
            month = today - relativedelta(months=i)
            start_month = month + relativedelta(day=1)
            end_month = last_day_of_month(start_month)
            avg = self.get_average_qa_rating(
                qa_field, from_range=start_month, to_range=end_month
            )
            months.append(str(start_month.date()))
            data.append(avg)

        data = {
            "months": months,
            "data": data,
        }
        return data

    def get_average_techqa_feedback_12mo(self):
        return self.get_average_qa_rating_12mo("techqa_report_rating")

    def get_average_presqa_feedback_12mo(self):
        return self.get_average_qa_rating_12mo("presqa_report_rating")

    def current_cost(self):
        if self.costs.all().exists():
            return self.costs.all().last()
        else:
            return None

    def update_cost(self, cost, effective_from=timezone.now()):
        return UserCost.objects.create(
            user=self, effective_from=effective_from, cost_per_hour=cost
        )

    def get_working_hours(self):
        # Logic should be working hours from our org?
        data = dict()
        if self.unit_memberships.exists():
            data["start"] = self.unit_memberships.first().unit.businessHours_startTime
            data["end"] = self.unit_memberships.first().unit.businessHours_endTime
        else:
            # Do site defaults...
            data["start"] = timezone.datetime.time(9, 0, 0)
            data["end"] = timezone.datetime.time(17, 30, 0)
        return data


class UserCost(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET(get_sentinel_user),
        related_name="costs",
    )
    effective_from = models.DateField(
        verbose_name="Effective From",
        null=True,
        blank=True,
        help_text="Date cost applies from",
    )
    cost_per_hour = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        verbose_name="Cost Per Hour",
        help_text="Cost of the user per hour",
    )

    class Meta:
        ordering = ["user", "-effective_from"]
        unique_together = ["user", "effective_from"]

    def __str__(self):
        return "{} {}".format(str(self.user), str(self.cost_per_hour))


class HolidayCountry(models.Model):
    country = CountryField()

    class Meta:
        ordering = [Lower("country")]

    def __str__(self):
        return "{}".format(str(self.country.name))


class Holiday(models.Model):
    date = models.DateField(db_index=True)
    country = models.ForeignKey(HolidayCountry, on_delete=models.CASCADE)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        return "{} ({})".format(str(self.reason), str(self.country))

    def get_schedule_json(self):
        return {
            "title": "{} ({})".format(self.reason, str(self.country)),
            "start": self.date,
            "end": self.date,
            "allDay": True,
            "display": "background",
            "id": self.pk,
        }

    class Meta:
        ordering = [
            "-date",
        ]
        unique_together = ["date", "country", "reason"]


class LeaveRequest(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="leave_records",
    )

    requested_on = models.DateTimeField(auto_now_add=True)
    start_date = models.DateTimeField(db_index=True)
    end_date = models.DateTimeField(db_index=True)

    type_of_leave = models.IntegerField(choices=LeaveRequestTypes.CHOICES)
    notes = models.TextField(blank=True)

    authorised = models.BooleanField(default=False)
    authorised_on = models.DateTimeField(null=True, blank=True)
    authorised_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name="leave_records_authorised",
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )

    timeslot = models.ForeignKey(
        "jobtracker.TimeSlot",
        related_name="leaverequest",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
    )

    cancelled = models.BooleanField(default=False)
    cancelled_on = models.DateTimeField(null=True, blank=True)

    declined = models.BooleanField(default=False)
    declined_on = models.DateTimeField(null=True, blank=True)
    declined_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name="leave_records_declined",
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )

    class Meta:
        verbose_name = "Leave Request"
        ordering = ["-start_date"]

    def overlaps_work(self):
        from jobtracker.models.timeslot import TimeSlotType

        return self.user.timeslots.filter(
            slot_type=DefaultTimeSlotTypes.DELIVERY,
            start__lte=self.end_date,
            end__gte=self.start_date,
        ).exists()

    def overlaps_confirmed_work(self):
        from jobtracker.models.timeslot import TimeSlotType, TimeSlot
        from jobtracker.enums import PhaseStatuses

        return self.user.timeslots.filter(
            slot_type=DefaultTimeSlotTypes.DELIVERY,
            phase__status__gte=PhaseStatuses.SCHEDULED_CONFIRMED,
            start__lte=self.end_date,
            end__gte=self.start_date,
        ).exists()

    def requested_late(self):
        return self.start_date < (
            self.requested_on + timedelta(days=config.LEAVE_DAYS_NOTICE)
        )

    def affected_days(self):
        unit = "hour"
        days = 0
        working_hours = self.user.get_working_hours()
        hours = businessDuration(
            self.start_date,
            self.end_date,
            unit=unit,
            starttime=working_hours["start"],
            endtime=working_hours["end"],
        )
        hours_in_working_day = (
            timezone.datetime.combine(timezone.now().date(), working_hours["end"])
            - timezone.datetime.combine(timezone.now().date(), working_hours["start"])
        ).total_seconds() / 3600
        if hours:
            days = hours / hours_in_working_day
        return round(days, 2)

    def can_cancel(self):
        # Only situ we can't cancel is if it's in the past or it's already cancelled.
        if self.start_date < timezone.now():
            return False
        if self.cancelled:
            return False
        return True

    def can_approve_by(self):
        # Update to reflect logic...
        user_pks = []
        if self.user.manager and self.user.manager.pk not in user_pks:
            user_pks.append(self.user.manager.pk)
        if self.user.acting_manager and self.user.acting_manager.pk not in user_pks:
            user_pks.append(self.user.acting_manager.pk)
        if not self.user.manager and not self.user.acting_manager:
            # No managers defined - can self approve
            user_pks.append(self.user.pk)

        # No managers - lets default to unit managers...
        for membership in self.user.unit_memberships.all():
            for pk in membership.unit.get_active_members_with_perm(
                "can_approve_leave_requests"
            ).values_list("pk", flat=True):
                if pk not in user_pks:
                    user_pks.append(pk)
        return User.objects.filter(pk__in=user_pks).distinct()

    def can_user_auth(self, user):
        if self.cancelled:
            return False
        if user == self.user.manager or user == self.user.acting_manager:
            return True

        if (
            not self.user.manager and not self.user.acting_manager
        ) and user == self.user:
            # No managers defined - can self approve
            return True
        for membership in self.user.unit_memberships.all():
            # Check if user has permission in any of the units...
            if user.has_perm("can_approve_leave_requests", membership.unit):
                return True
        return False

    EMAIL_TEMPLATE = "emails/leave.html"

    def send_request_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = self.can_approve_by()
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Requested - Please review",
            str(self.user) + " has requested leave. Please review the request",
            self.EMAIL_TEMPLATE,
            action_link=reverse("manage_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_approved_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Approved",
            "Your leave ({start_date} - {end_date}) has been approved!".format(
                start_date=self.start_date, end_date=self.end_date
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_declined_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave DECLINED",
            "Your leave ({start_date} - {end_date}) has been declined. Please contact {declined_by} for information.".format(
                start_date=self.start_date,
                end_date=self.end_date,
                declined_by=self.declined_by,
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_cancelled_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Cancelled",
            "You have cancelled your leave ({start_date} - {end_date}).".format(
                start_date=self.start_date, end_date=self.end_date
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def authorise(self, approved_by):
        from jobtracker.models.timeslot import TimeSlot, TimeSlotType

        if self.cancelled:
            # Can't auth at this stage
            return False
        if not self.authorised:
            # Set our important fields
            self.authorised = True
            self.authorised_by = approved_by
            self.authorised_on = timezone.now()
            # Lets add the timeslot...
            ts, ts_created = TimeSlot.objects.get_or_create(
                user=self.user,
                start=self.start_date,
                end=self.end_date,
                slot_type=TimeSlotType.get_builtin_object(DefaultTimeSlotTypes.LEAVE),
            )
            self.timeslot = ts
            self.save()
            self.send_approved_notification()

    def decline(self, declined_by):
        pass

        if self.authorised or self.cancelled:
            # Can't decline at this stage
            return False
        if not self.declined:
            # Set our important fields
            self.declined = True
            self.declined_by = declined_by
            self.declined_on = timezone.now()
            self.save()
            self.send_declined_notification()

    def cancel(self):
        from jobtracker.models.timeslot import TimeSlot, TimeSlotType

        if not self.cancelled:
            # Set our important fields
            self.cancelled = True
            self.cancelled_on = timezone.now()
            self.authorised = False
            self.declined = False
            # Lets delete the timeslot...
            if self.timeslot:
                self.timeslot.delete()
            self.save()
            self.send_cancelled_notification()
