from django.db import models
from django.contrib.auth.models import Permission
import uuid
import os
from ..managers import SystemNoteManager
from ..enums import GlobalRoles, LeaveRequestTypes, NotificationTypes
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
import django.contrib.auth
from guardian.shortcuts import assign_perm
from django.utils import timezone
from datetime import timedelta, date
from django.db.models.functions import Lower
from django_countries.fields import CountryField
from ..tasks import task_send_notifications
from jobtracker.enums import DefaultTimeSlotTypes
from business_duration import businessDuration
from constance import config
from django.template.loader import render_to_string
import django.core.mail


def get_sentinel_user():
    return get_user_model().objects.get_or_create(email="deleted@chaotica.app")[0]


class Note(models.Model):
    create_date = models.DateTimeField(
        verbose_name="Created",
        auto_now_add=True,
        help_text="Date the record was created",
    )
    mod_date = models.DateTimeField(
        verbose_name="Last Modified",
        auto_now=True,
        help_text="Date the record was last modified",
    )
    history = HistoricalRecords()
    content = models.TextField(
        verbose_name="Content", blank=True, help_text="Note Text"
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )
    is_system_note = models.BooleanField(
        default=False,
        help_text="Is the note generated by the system",
        verbose_name="System Note",
    )
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ["-create_date"]


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=255, default="")
    icon = models.CharField(max_length=255, blank=True, null=True, default="")
    message = models.TextField(default="")
    link = models.URLField(blank=True, null=True)
    is_read = models.BooleanField(default=False)
    email_template = models.CharField(max_length=255, default="")
    is_emailed = models.BooleanField(default=False)

    class Meta:
        ordering = ["-timestamp"]

    def send_email(self, resend=False):
        self.refresh_from_db()  # Make sure we're using the latest info!

        if (
            self.user.is_active  # User must be active
            and config.EMAIL_ENABLED  # Emails must be enabled
            and (
                self.is_emailed == False or resend == True
            )  # Either we've not already sent it or we're resending it
        ):
            context = {}
            context["SITE_DOMAIN"] = settings.SITE_DOMAIN
            context["SITE_PROTO"] = settings.SITE_PROTO
            context["title"] = self.title
            context["message"] = self.message
            context["icon"] = self.icon
            context["action_link"] = self.link
            context["user"] = self.user
            msg_html = render_to_string(self.email_template, context)
            django.core.mail.send_mail(
                subject=self.title,
                message=self.message,
                from_email=None,
                recipient_list=[self.user.email_address()],
                html_message=msg_html,
            )

        # Mark it as sent regardless - don't want to create a backlog
        self.is_emailed = True
        self.save()


def get_media_profile_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("profile_pics", filename)


def get_media_image_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("images", filename)


class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = [Lower("display_name")]
        unique_together = ["lang_code", "display_name"]

    def __str__(self):
        return "{}".format(self.display_name)


class HolidayManager(models.Manager):
    def get_date_list(self, start_date, end_date, country=None):
        if not (isinstance(start_date, date) and isinstance(end_date, date)):
            raise TypeError(
                "Both start_date and end_date must be datetime.date objects"
            )

        matches = self.filter(date__gte=start_date, date__lte=end_date)

        if country:
            matches.filter(country=country)

        data = matches.values_list("date", flat=True)
        return data


class Holiday(models.Model):
    objects = HolidayManager()
    date = models.DateField(db_index=True)
    country = CountryField(blank=True, null=True)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        if self.country:
            return "{} ({})".format(str(self.reason), str(self.country))
        else:
            return "{}".format(str(self.reason))

    def get_schedule_json(self):
        return {
            "title": str(self),
            "start": self.date,
            "end": self.date,
            "allDay": True,
            "display": "background",
            "id": self.pk,
        }

    class Meta:
        ordering = [
            "country",
            "date",
        ]
        unique_together = ["date", "country", "reason"]

