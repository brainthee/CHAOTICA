from django.db import models
from django.contrib.auth.models import Permission
import uuid
import os
from ..managers import SystemNoteManager
from ..enums import GlobalRoles, LeaveRequestTypes, NotificationTypes
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.urls import reverse
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
import django.contrib.auth
from guardian.shortcuts import assign_perm
from django.utils import timezone
from datetime import timedelta, date
from django.db.models.functions import Lower
from django_countries.fields import CountryField
from ..tasks import task_send_notifications
from jobtracker.enums import DefaultTimeSlotTypes
from business_duration import businessDuration
from constance import config
from django.template.loader import render_to_string
import django.core.mail


def get_sentinel_user():
    return get_user_model().objects.get_or_create(email="deleted@chaotica.app")[0]


class Note(models.Model):
    create_date = models.DateTimeField(
        verbose_name="Created",
        auto_now_add=True,
        help_text="Date the record was created",
    )
    mod_date = models.DateTimeField(
        verbose_name="Last Modified",
        auto_now=True,
        help_text="Date the record was last modified",
    )
    history = HistoricalRecords()
    content = models.TextField(
        verbose_name="Content", blank=True, help_text="Note Text"
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )
    is_system_note = models.BooleanField(
        default=False,
        help_text="Is the note generated by the system",
        verbose_name="System Note",
    )
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ["-create_date"]


class Notification(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timestamp = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=255, default="")
    icon = models.CharField(max_length=255, blank=True, null=True, default="")
    message = models.TextField(default="")
    link = models.URLField(blank=True, null=True)
    is_read = models.BooleanField(default=False)
    email_template = models.CharField(max_length=255, default="")
    is_emailed = models.BooleanField(default=False)

    class Meta:
        ordering = ["-timestamp"]

    def send_email(self, resend=False):
        self.refresh_from_db()  # Make sure we're using the latest info!

        if (
            self.user.is_active  # User must be active
            and config.EMAIL_ENABLED  # Emails must be enabled
            and (
                self.is_emailed == False or resend == True
            )  # Either we've not already sent it or we're resending it
        ):
            context = {}
            context["SITE_DOMAIN"] = settings.SITE_DOMAIN
            context["SITE_PROTO"] = settings.SITE_PROTO
            context["title"] = self.title
            context["message"] = self.message
            context["icon"] = self.icon
            context["action_link"] = self.link
            context["user"] = self.user
            msg_html = render_to_string(self.email_template, context)
            django.core.mail.send_mail(
                subject=self.title,
                message=self.message,
                from_email=None,
                recipient_list=[self.user.email_address()],
                html_message=msg_html,
            )

        # Mark it as sent regardless - don't want to create a backlog
        self.is_emailed = True
        self.save()


def get_media_profile_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("profile_pics", filename)


def get_media_image_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("images", filename)


class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = [Lower("display_name")]
        unique_together = ["lang_code", "display_name"]

    def __str__(self):
        return "{}".format(self.display_name)


class HolidayManager(models.Manager):
    def get_date_list(self, start_date, end_date, country=None):
        if not (isinstance(start_date, date) and isinstance(end_date, date)):
            raise TypeError(
                "Both start_date and end_date must be datetime.date objects"
            )

        matches = self.filter(date__gte=start_date, date__lte=end_date)

        if country:
            matches.filter(country=country)

        data = matches.values_list("date", flat=True)
        return data


class Holiday(models.Model):
    objects = HolidayManager()
    date = models.DateField(db_index=True)
    country = CountryField(blank=True, null=True)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        if self.country:
            return "{} ({})".format(str(self.reason), str(self.country))
        else:
            return "{}".format(str(self.reason))

    def get_schedule_json(self):
        return {
            "title": str(self),
            "start": self.date,
            "end": self.date,
            "allDay": True,
            "display": "background",
            "id": self.pk,
        }

    class Meta:
        ordering = [
            "country",
            "date",
        ]
        unique_together = ["date", "country", "reason"]


class LeaveRequest(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="leave_records",
    )

    requested_on = models.DateTimeField(auto_now_add=True)
    start_date = models.DateTimeField(db_index=True)
    end_date = models.DateTimeField(db_index=True)

    type_of_leave = models.IntegerField(choices=LeaveRequestTypes.CHOICES)
    notes = models.TextField(blank=True)

    authorised = models.BooleanField(default=False)
    authorised_on = models.DateTimeField(null=True, blank=True)
    authorised_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name="leave_records_authorised",
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )

    timeslot = models.ForeignKey(
        "jobtracker.TimeSlot",
        related_name="leaverequest",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
    )

    cancelled = models.BooleanField(default=False)
    cancelled_on = models.DateTimeField(null=True, blank=True)

    declined = models.BooleanField(default=False)
    declined_on = models.DateTimeField(null=True, blank=True)
    declined_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        related_name="leave_records_declined",
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )

    class Meta:
        verbose_name = "Leave Request"
        ordering = ["-start_date"]

    def overlaps_work(self):
        return self.user.timeslots.filter(
            slot_type=DefaultTimeSlotTypes.DELIVERY,
            start__lte=self.end_date,
            end__gte=self.start_date,
        ).exists()

    def overlaps_confirmed_work(self):
        from jobtracker.enums import PhaseStatuses

        return self.user.timeslots.filter(
            slot_type=DefaultTimeSlotTypes.DELIVERY,
            phase__status__gte=PhaseStatuses.SCHEDULED_CONFIRMED,
            start__lte=self.end_date,
            end__gte=self.start_date,
        ).exists()

    def requested_late(self):
        return self.start_date < (
            self.requested_on + timedelta(days=config.LEAVE_DAYS_NOTICE)
        )

    def affected_days(self):
        unit = "hour"
        days = 0
        working_hours = self.user.get_working_hours()
        hours = businessDuration(
            self.start_date,
            self.end_date,
            unit=unit,
            starttime=working_hours["start"],
            endtime=working_hours["end"],
        )
        hours_in_working_day = (
            timezone.datetime.combine(timezone.now().date(), working_hours["end"])
            - timezone.datetime.combine(timezone.now().date(), working_hours["start"])
        ).total_seconds() / 3600
        if hours:
            days = hours / hours_in_working_day
        return round(days, 2)

    def can_cancel(self):
        # Only situ we can't cancel is if it's in the past or it's already cancelled.
        if self.start_date < timezone.now():
            return False
        if self.cancelled:
            return False
        return True

    def can_approve_by(self):
        from ..models import User

        # Update to reflect logic...
        user_pks = []
        if self.user.manager and self.user.manager.pk not in user_pks:
            user_pks.append(self.user.manager.pk)
        if self.user.acting_manager and self.user.acting_manager.pk not in user_pks:
            user_pks.append(self.user.acting_manager.pk)
        if not self.user.manager and not self.user.acting_manager:
            # No managers defined - can self approve
            user_pks.append(self.user.pk)

        return User.objects.filter(pk__in=user_pks).distinct()

    def can_user_auth(self, user):
        if self.cancelled:
            return False
        if user == self.user.manager or user == self.user.acting_manager:
            return True

        if (
            not self.user.manager and not self.user.acting_manager
        ) and user == self.user:
            # No managers defined - can self approve
            return True
        for membership in self.user.unit_memberships.all():
            # Check if user has permission in any of the units...
            if user.has_perm("can_approve_leave_requests", membership.unit):
                return True
        return False

    EMAIL_TEMPLATE = "emails/leave.html"

    def send_request_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = self.can_approve_by()
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Requested - Please review",
            str(self.user) + " has requested leave. Please review the request",
            self.EMAIL_TEMPLATE,
            action_link=reverse("manage_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_approved_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Approved",
            "Your leave ({start_date} - {end_date}) has been approved!".format(
                start_date=self.start_date, end_date=self.end_date
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_declined_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave DECLINED",
            "Your leave ({start_date} - {end_date}) has been declined. Please contact {declined_by} for information.".format(
                start_date=self.start_date,
                end_date=self.end_date,
                declined_by=self.declined_by,
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def send_cancelled_notification(self):
        from chaotica_utils.utils import AppNotification

        # Send a notice to... people?!
        users_to_notify = [self.user]
        notice = AppNotification(
            NotificationTypes.PHASE,
            "Leave Cancelled",
            "You have cancelled your leave ({start_date} - {end_date}).".format(
                start_date=self.start_date, end_date=self.end_date
            ),
            self.EMAIL_TEMPLATE,
            action_link=reverse("view_own_leave"),
            leave=self,
        )
        task_send_notifications(notice, users_to_notify)

    def authorise(self, approved_by):
        from jobtracker.models.timeslot import TimeSlot, TimeSlotType

        if self.cancelled:
            # Can't auth at this stage
            return False
        if not self.authorised:
            # Set our important fields
            self.authorised = True
            self.authorised_by = approved_by
            self.authorised_on = timezone.now()
            # Lets add the timeslot...
            ts, ts_created = TimeSlot.objects.get_or_create(
                user=self.user,
                start=self.start_date,
                end=self.end_date,
                slot_type=TimeSlotType.get_builtin_object(DefaultTimeSlotTypes.LEAVE),
            )
            self.timeslot = ts
            self.save()
            self.send_approved_notification()

    def decline(self, declined_by):
        pass

        if self.authorised or self.cancelled:
            # Can't decline at this stage
            return False
        if not self.declined:
            # Set our important fields
            self.declined = True
            self.declined_by = declined_by
            self.declined_on = timezone.now()
            self.save()
            self.send_declined_notification()

    def cancel(self):
        from jobtracker.models.timeslot import TimeSlot, TimeSlotType

        if not self.cancelled:
            # Set our important fields
            self.cancelled = True
            self.cancelled_on = timezone.now()
            self.authorised = False
            self.declined = False
            # Lets delete the timeslot...
            if self.timeslot:
                self.timeslot.delete()
            self.save()
            self.send_cancelled_notification()
