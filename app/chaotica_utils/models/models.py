from django.db import models
import uuid
import os
from ..managers import SystemNoteManager
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey
from django.conf import settings
from django.contrib.auth import get_user_model
from simple_history.models import HistoricalRecords
from datetime import date
from django.db.models.functions import Lower
from django_countries.fields import CountryField
from ..utils import get_sentinel_user


class Note(models.Model):
    create_date = models.DateTimeField(
        verbose_name="Created",
        auto_now_add=True,
        help_text="Date the record was created",
    )
    mod_date = models.DateTimeField(
        verbose_name="Last Modified",
        auto_now=True,
        help_text="Date the record was last modified",
    )
    history = HistoricalRecords()
    content = models.TextField(
        verbose_name="Content", blank=True, help_text="Note Text"
    )
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET(get_sentinel_user),
    )
    is_system_note = models.BooleanField(
        default=False,
        help_text="Is the note generated by the system",
        verbose_name="System Note",
    )
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey("content_type", "object_id")

    system_objects = SystemNoteManager()
    objects = models.Manager()

    class Meta:
        verbose_name = "Note"
        verbose_name_plural = "Notes"
        ordering = ["-create_date"]


def get_media_profile_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("profile_pics", filename)


def get_media_image_file_path(_, filename):
    ext = filename.split(".")[-1]
    filename = "%s.%s" % (uuid.uuid4(), ext)
    return os.path.join("images", filename)


class Language(models.Model):
    lang_code = models.CharField(max_length=10)
    display_name = models.CharField(max_length=255)

    class Meta:
        ordering = [Lower("display_name")]
        unique_together = ["lang_code", "display_name"]

    def __str__(self):
        return "{}".format(self.display_name)


class HolidayManager(models.Manager):
    def get_date_list(self, start_date, end_date, country=None):
        if not (isinstance(start_date, date) and isinstance(end_date, date)):
            raise TypeError(
                "Both start_date and end_date must be datetime.date objects"
            )

        matches = self.filter(date__gte=start_date, date__lte=end_date)

        if country:
            matches.filter(country=country)

        data = matches.values_list("date", flat=True)
        return data


class Holiday(models.Model):
    objects = HolidayManager()
    date = models.DateField(db_index=True)
    country = CountryField(blank=True, null=True)
    subdivs = models.JSONField(default=list, blank=True)
    reason = models.CharField(max_length=255)

    def __str__(self):
        if self.country:
            return "{} ({})".format(str(self.reason), str(self.country))
        else:
            return "{}".format(str(self.reason))

    def get_schedule_json(self):
        return {
            "title": str(self),
            "start": self.date,
            "end": self.date,
            "allDay": True,
            "display": "background",
            "id": self.pk,
        }

    class Meta:
        ordering = [
            "country",
            "date",
        ]
        unique_together = ["date", "country", "reason"]


class IPTag(models.Model):
    """
    Represents a tag for IP addresses (e.g., "Office", "VPN", "Home").
    Each tag can have multiple CIDR ranges associated with it.
    """
    name = models.CharField(
        max_length=100,
        unique=True,
        help_text="Tag name (e.g., Office, VPN, Home)"
    )
    description = models.TextField(
        blank=True,
        help_text="Optional description of what this tag represents"
    )
    color = models.CharField(
        max_length=7,
        default="#6c757d",
        help_text="Hex color code for the tag badge (e.g., #007bff)"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this tag is active and should be used"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "IP Tag"
        verbose_name_plural = "IP Tags"
        ordering = ["name"]

    def __str__(self):
        return self.name

    def get_cidr_ranges(self):
        """Return all CIDR ranges for this tag."""
        return self.cidrranges.all()


class IPCIDRRange(models.Model):
    """
    Represents a CIDR range associated with an IP tag.
    """
    tag = models.ForeignKey(
        IPTag,
        on_delete=models.CASCADE,
        related_name="cidrranges",
        help_text="The tag this CIDR range belongs to"
    )
    cidr = models.CharField(
        max_length=43,  # Max length for IPv6 CIDR (e.g., 2001:db8::/32)
        help_text="CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32)"
    )
    description = models.CharField(
        max_length=255,
        blank=True,
        help_text="Optional description of this CIDR range"
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether this CIDR range is active"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "IP CIDR Range"
        verbose_name_plural = "IP CIDR Ranges"
        ordering = ["tag__name", "cidr"]
        unique_together = ["tag", "cidr"]

    def __str__(self):
        return f"{self.tag.name}: {self.cidr}"

    def get_network(self):
        """Return the ipaddress.IPv4Network or IPv6Network object."""
        import ipaddress
        return ipaddress.ip_network(self.cidr, strict=False)

